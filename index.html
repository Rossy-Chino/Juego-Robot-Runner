<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Robo Runner 3D - Web</title>
  <style>
    body { margin:0; font-family: Arial, sans-serif; background:#000; color:#fff; overflow:hidden; }
    .screen { display:none; width:100vw; height:100vh; position:absolute; top:0; left:0; }
    #menu { display:flex; flex-direction:column; align-items:center; justify-content:center; gap:18px; background:linear-gradient(180deg,#0b0b0b,#121212); }
    .title { font-size:44px; letter-spacing:2px; }
    .btn { padding:12px 36px; background:#0d6efd; border:none; color:white; border-radius:8px; font-size:20px; cursor:pointer; transition:.12s; }
    .btn:hover { transform:scale(1.05); }
    #juego { background:#000; }
    #hud { position:fixed; top:10px; left:10px; background:rgba(0,0,0,.45); padding:8px 10px; border-radius:6px; font-size:14px; }
  </style>
</head>
<body>

<!-- MENU -->
<div id="menu" class="screen">
  <div class="title">ROBO RUNNER 3D</div>
  <button class="btn" onclick="startGame()">Jugar</button>
  <button class="btn" onclick="showOptions()">Opciones</button>
  <button class="btn" onclick="window.close()">Salir</button>
</div>

<!-- OPCIONES -->
<div id="options" class="screen" style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
  <h2>Opciones</h2>
  <p>Controles: A / D o Flechas izquierda/derecha</p>
  <button class="btn" onclick="backToMenu()">Volver</button>
</div>

<!-- JUEGO -->
<div id="juego" class="screen"></div>
<div id="hud" style="display:none">Puntuación: <span id="score">0</span></div>

<!-- Three.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/* -----------------------
   Gestión de pantallas
   ----------------------- */
function hideAll() { document.querySelectorAll('.screen').forEach(s=>s.style.display='none'); }
function showMenu(){ hideAll(); document.getElementById('menu').style.display='flex'; document.getElementById('hud').style.display='none'; }
function showOptions(){ hideAll(); document.getElementById('options').style.display='flex'; }
function backToMenu(){ showMenu(); resetGameState(); }

/* arrancar en menu */
showMenu();

/* -----------------------
   Variables del juego
   ----------------------- */
let started = false;
let scene, camera, renderer;
let robot, obstacles = [];
let speed = 0.8;            // velocidad con la que los obstáculos se acercan
let lateralX = 0;          // posición lateral del robot
let score = 0;
let gameLoopId = null;

/* -----------------------
   Iniciar juego
   ----------------------- */
function startGame(){
  hideAll();
  document.getElementById('juego').style.display = 'block';
  document.getElementById('hud').style.display = 'block';
  if(!started) initGame();
}

/* -----------------------
   Inicialización 3D
   ----------------------- */
function initGame(){
  started = true;
  score = 0;
  document.getElementById('score').innerText = score;
  obstacles = [];
  lateralX = 0;
  gameLoopId = null;
  gameOverFlag = false;

  // contenedor
  const container = document.getElementById('juego');

  // escena
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  // cámara
  camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 4, 8);

  // renderer
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.innerHTML = ''; // limpiar
  container.appendChild(renderer.domElement);

  // luz
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 1.2);
  scene.add(hemi);
  const light = new THREE.DirectionalLight(0xffffff, 0.8);
  light.position.set(5,10,5);
  scene.add(light);

  // pista (sólo de referencia visual)
  const pistaGeom = new THREE.BoxGeometry(6, 0.2, 400);
  const pistaMat = new THREE.MeshStandardMaterial({color:0x101030});
  const pista = new THREE.Mesh(pistaGeom, pistaMat);
  pista.position.z = -120;
  scene.add(pista);

  // robot (permanece en z=0)
  const rGeo = new THREE.BoxGeometry(1,1,1);
  const rMat = new THREE.MeshStandardMaterial({color:0x00ff9a});
  robot = new THREE.Mesh(rGeo, rMat);
  robot.position.set(0, 0.6, 0);
  scene.add(robot);

  // crear obstáculos iniciales (estarán delante, con z negativo y se moverán hacia z=0)
  for(let i=0;i<30;i++){
    const x = (Math.random()*4)-2;         // rango lateral [-2,2]
    const z = -(20 + i * 8 + Math.random()*6); // z negativo (adelante)
    createObstacle(x, z);
  }

  // controles
  window.addEventListener('keydown', keyDownHandler);

  // responsivo
  window.addEventListener('resize', onResize);

  // iniciar animación
  animate();
}

/* -----------------------
   Crear obstáculo
   ----------------------- */
function createObstacle(x,z){
  const geo = new THREE.BoxGeometry(1,1.5,1);
  const mat = new THREE.MeshStandardMaterial({color:0xff4444});
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, 0.75, z);
  scene.add(mesh);
  obstacles.push(mesh);
}

/* -----------------------
   Controles
   ----------------------- */
function keyDownHandler(e){
  if(e.key === 'ArrowLeft' || e.key === 'a') lateralX = Math.max(-2.2, lateralX - 0.8);
  if(e.key === 'ArrowRight' || e.key === 'd') lateralX = Math.min(2.2, lateralX + 0.8);
}

/* -----------------------
   Animación principal
   ----------------------- */
let gameOverFlag = false;
function animate(){
  gameLoopId = requestAnimationFrame(animate);

  // mover obstáculos hacia el robot (z aumenta)
  for(let i=obstacles.length-1;i>=0;i--){
    const o = obstacles[i];
    o.position.z += speed * 0.6; // se acercan

    // si pasa detrás del robot, reciclarlo más adelante para endless feel
    if(o.position.z > 6){
      // moverlo hacia atrás con nueva x
      o.position.z = -(150 + Math.random()*80);
      o.position.x = (Math.random()*4)-2;
      // aumentar score ligeramente
      score += 10;
      document.getElementById('score').innerText = score;
    }
  }

  // aplicar posicion lateral al robot (su z se mantiene en 0)
  robot.position.x = lateralX;

  // colisiones (bounding-box simple)
  for(const o of obstacles){
    const dz = Math.abs(o.position.z - robot.position.z);
    const dx = Math.abs(o.position.x - robot.position.x);
    if(dz < 1.0 && dx < 0.9){
      // choque
      gameOver();
      break;
    }
  }

  // cámara sigue ligeramente al robot en x
  camera.position.x += (robot.position.x - camera.position.x) * 0.08;
  camera.lookAt(new THREE.Vector3(robot.position.x, 1.2, -10));

  renderer.render(scene, camera);
}

/* -----------------------
   Game Over
   ----------------------- */
function gameOver(){
  if(gameOverFlag) return;
  gameOverFlag = true;
  cancelAnimationFrame(gameLoopId);
  setTimeout(()=> {
    alert('¡Has chocado! Puntaje: ' + score);
    resetGameState();
    showMenu();
  }, 60);
}

/* -----------------------
   Reset estado
   ----------------------- */
function resetGameState(){
  started = false;
  if(renderer && renderer.domElement) {
    // destruir renderer para liberar memoria (opcional)
    try { renderer.forceContextLoss && renderer.forceContextLoss(); } catch(e){}
  }
  // quitar listeners
  window.removeEventListener('keydown', keyDownHandler);
  window.removeEventListener('resize', onResize);
}

/* -----------------------
   Resize
   ----------------------- */
function onResize(){
  if(!camera||!renderer) return;
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>

</body>
</html>
